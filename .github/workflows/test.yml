name: Test Git Worktree Workflow

on:
  pull_request:
    branches: [ main, master, develop ]
    paths-ignore:
      - '*.md'
      - 'docs/**'

jobs:
  # Fast feedback: unit tests, linting, formatting on Ubuntu only
  unit-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v6

    - name: Set up Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
        components: rustfmt, clippy

    - name: Cache Rust dependencies
      uses: actions/cache@v5
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ubuntu-latest-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ubuntu-latest-cargo-

    - name: Build Rust binaries
      run: cargo build --release

    - name: Clean old binaries from cache
      run: |
        # Remove any old binaries that might be in cache from before src/bin/ was removed
        rm -f target/release/git-worktree-*
        echo "Cleaned old binaries from cache"

    - name: Verify single binary architecture
      run: |
        echo "Verifying single binary architecture..."
        # Count executables in target/release (excluding .d files, .dSYM, and symlinks)
        # Use a portable approach: find files and test if executable with shell
        BINARY_COUNT=0
        for file in target/release/*; do
          if [ -f "$file" ] && [ ! -L "$file" ] && [ -x "$file" ]; then
            case "$file" in
              *.d) ;;  # Skip .d files
              *) BINARY_COUNT=$((BINARY_COUNT + 1)) ;;
            esac
          fi
        done
        echo "Found $BINARY_COUNT binary executable(s)"

        # Verify exactly 1 binary exists
        if [ "$BINARY_COUNT" -ne 1 ]; then
          echo "ERROR: Expected exactly 1 binary, found $BINARY_COUNT"
          echo "Binaries found:"
          for file in target/release/*; do
            if [ -f "$file" ] && [ ! -L "$file" ] && [ -x "$file" ]; then
              case "$file" in
                *.d) ;;
                *) ls -lh "$file" ;;
              esac
            fi
          done
          exit 1
        fi

        # Verify it's named 'daft'
        if [ ! -f target/release/daft ]; then
          echo "ERROR: Binary 'daft' not found"
          exit 1
        fi

        echo "Single binary architecture verified: daft binary exists"
        ls -lh target/release/daft

    - name: Run Rust unit tests
      run: cargo test --lib

    - name: Run Rust clippy
      run: cargo clippy -- -D warnings

    - name: Check Rust formatting
      run: cargo fmt -- --check

  # Cross-platform integration tests (where platform differences matter)
  integration-tests:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]

    steps:
    - uses: actions/checkout@v6

    - name: Set up Git
      run: |
        git config --global user.name "Test User"
        git config --global user.email "test@example.com"

    - name: Set up Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true

    - name: Cache Rust dependencies
      uses: actions/cache@v5
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ matrix.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ matrix.os }}-cargo-

    - name: Build Rust binaries
      run: cargo build --release

    - name: Clean old binaries from cache
      run: |
        # Remove any old binaries that might be in cache from before src/bin/ was removed
        rm -f target/release/git-worktree-*
        echo "Cleaned old binaries from cache"

    - name: Verify single binary architecture
      run: |
        echo "Verifying single binary architecture..."
        # Count executables in target/release (excluding .d files, .dSYM, and symlinks)
        # Use a portable approach: find files and test if executable with shell
        BINARY_COUNT=0
        for file in target/release/*; do
          if [ -f "$file" ] && [ ! -L "$file" ] && [ -x "$file" ]; then
            case "$file" in
              *.d) ;;  # Skip .d files
              *) BINARY_COUNT=$((BINARY_COUNT + 1)) ;;
            esac
          fi
        done
        echo "Found $BINARY_COUNT binary executable(s)"

        # Verify exactly 1 binary exists
        if [ "$BINARY_COUNT" -ne 1 ]; then
          echo "ERROR: Expected exactly 1 binary, found $BINARY_COUNT"
          echo "Binaries found:"
          for file in target/release/*; do
            if [ -f "$file" ] && [ ! -L "$file" ] && [ -x "$file" ]; then
              case "$file" in
                *.d) ;;
                *) ls -lh "$file" ;;
              esac
            fi
          done
          exit 1
        fi

        # Verify it's named 'daft'
        if [ ! -f target/release/daft ]; then
          echo "ERROR: Binary 'daft' not found"
          exit 1
        fi

        echo "Single binary architecture verified: daft binary exists"
        ls -lh target/release/daft

    - name: Make test scripts executable
      run: chmod +x tests/integration/*.sh

    - name: Create symlinks for Rust binaries
      run: |
        # Create symlinks for the new multicall binary
        cd target/release
        ln -sf daft git-worktree-clone
        ln -sf daft git-worktree-init
        ln -sf daft git-worktree-checkout
        ln -sf daft git-worktree-checkout-branch
        ln -sf daft git-worktree-checkout-branch-from-default
        ln -sf daft git-worktree-prune
        ln -sf daft git-worktree-carry
        ln -sf daft git-worktree-fetch
        ln -sf daft git-daft
        cd ../..

    - name: Add Rust binaries to PATH
      run: |
        echo "${{ github.workspace }}/target/release" >> $GITHUB_PATH
        echo "PATH=${{ github.workspace }}/target/release:$PATH" >> $GITHUB_ENV

    - name: Install just
      uses: extractions/setup-just@v2
      with:
        just-version: 1.37.0

    - name: Test script dependencies
      run: |
        echo "Testing required dependencies..."
        which git || { echo "Git not found"; exit 1; }
        which awk || { echo "AWK not found"; exit 1; }
        which basename || { echo "basename not found"; exit 1; }
        echo "All dependencies found"

    - name: Run Rust integration tests
      run: just test-integration

    - name: Test shell completions
      run: |
        echo "Testing completion generation..."
        ./tests/integration/test_completions.sh

    - name: Test help commands
      run: |
        # Test Rust binary help (via symlinks)
        ./target/release/git-worktree-clone --help
        ./target/release/git-worktree-checkout --help
        ./target/release/git-worktree-checkout-branch --help
        ./target/release/git-worktree-checkout-branch-from-default --help
        ./target/release/git-worktree-init --help
        ./target/release/git-worktree-prune --help
        ./target/release/git-worktree-carry --help
        ./target/release/git-worktree-fetch --help

        # Test git daft documentation command
        ./target/release/daft | head -20
        ./target/release/git-daft | head -20

    - name: Upload test results
      uses: actions/upload-artifact@v6
      if: always()
      with:
        name: test-results-${{ matrix.os }}
        path: |
          tests/test-results.log
        retention-days: 7
        if-no-files-found: ignore

  # Simulate Homebrew installation to catch formula issues before release
  homebrew-simulation:
    runs-on: macos-latest
    needs: integration-tests
    steps:
    - uses: actions/checkout@v6

    - name: Set up Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true

    - name: Cache Rust dependencies
      uses: actions/cache@v5
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: macos-latest-cargo-homebrew-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          macos-latest-cargo-homebrew-
          macos-latest-cargo-

    - name: Build Rust binaries
      run: cargo build --release

    - name: Simulate Homebrew installation
      run: |
        PREFIX="$HOME/.local"
        mkdir -p "$PREFIX/bin" "$PREFIX/share/man/man1"

        # Install main binary
        cp target/release/daft "$PREFIX/bin/"
        chmod +x "$PREFIX/bin/daft"

        # Create symlinks for all commands (matching Homebrew formula)
        for cmd in git-worktree-clone git-worktree-checkout git-worktree-checkout-branch \
                   git-worktree-checkout-branch-from-default git-worktree-init \
                   git-worktree-prune git-worktree-carry git-worktree-fetch git-daft; do
          ln -sf daft "$PREFIX/bin/$cmd"
        done

        # Generate and install man pages
        "$PREFIX/bin/daft" man --output-dir "$PREFIX/share/man/man1"

        echo "Installation complete. Installed files:"
        ls -la "$PREFIX/bin/"
        ls -la "$PREFIX/share/man/man1/"

    - name: Verify symlinks work
      run: |
        PREFIX="$HOME/.local"
        export PATH="$PREFIX/bin:$PATH"

        echo "Verifying daft binary..."
        daft --version

        echo "Verifying all symlinked commands..."
        for cmd in git-worktree-clone git-worktree-checkout git-worktree-checkout-branch \
                   git-worktree-checkout-branch-from-default git-worktree-init \
                   git-worktree-prune git-worktree-carry git-worktree-fetch git-daft; do
          echo "  Testing $cmd..."
          "$PREFIX/bin/$cmd" --help > /dev/null || { echo "FAILED: $cmd --help"; exit 1; }
        done

        echo "All symlinked commands verified!"

    - name: Verify man pages
      run: |
        PREFIX="$HOME/.local"

        echo "Verifying man pages exist and are valid..."
        # Only git-worktree-* commands have man pages (not daft or git-daft)
        for page in git-worktree-clone git-worktree-checkout git-worktree-checkout-branch \
                    git-worktree-checkout-branch-from-default git-worktree-init \
                    git-worktree-prune git-worktree-carry git-worktree-fetch; do
          MANFILE="$PREFIX/share/man/man1/${page}.1"
          if [ ! -f "$MANFILE" ]; then
            echo "FAILED: Missing man page: $page"
            exit 1
          fi
          # Verify it's valid groff format (has .TH header)
          if ! head -20 "$MANFILE" | grep -q '\.TH'; then
            echo "FAILED: Invalid man page format: $page"
            exit 1
          fi
          echo "  $page.1 - OK"
        done

        echo "All man pages verified!"

    - name: Test installation with git prefix
      run: |
        PREFIX="$HOME/.local"
        export PATH="$PREFIX/bin:$PATH"

        # Verify git can discover the commands
        echo "Testing git command discovery..."
        git worktree-clone --help > /dev/null || { echo "FAILED: git worktree-clone not found"; exit 1; }
        git worktree-checkout --help > /dev/null || { echo "FAILED: git worktree-checkout not found"; exit 1; }
        git daft --help > /dev/null || { echo "FAILED: git daft not found"; exit 1; }

        echo "Git command discovery verified!"
        echo "Homebrew simulation test PASSED!"
