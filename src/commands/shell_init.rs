use anyhow::Result;
use clap::{Parser, ValueEnum};

#[derive(Debug, Clone, ValueEnum)]
pub enum Shell {
    Bash,
    Zsh,
    Fish,
}

#[derive(Parser)]
#[command(name = "shell-init")]
#[command(about = "Generate shell wrapper functions for daft commands")]
#[command(long_about = r#"
Generate shell wrapper functions that enable automatic cd into new worktrees.

By default, when daft commands create or switch to a worktree, the process changes
directory but the parent shell remains in the original directory. These wrappers
solve this by reading the CD target from a temp file and using the shell's builtin cd.

Add to your shell config:
  Bash (~/.bashrc):  eval "$(daft shell-init bash)"
  Zsh  (~/.zshrc):   eval "$(daft shell-init zsh)"
  Fish (~/.config/fish/config.fish): daft shell-init fish | source

With short aliases (gwco, etc.):
  eval "$(daft shell-init bash --aliases)"
"#)]
pub struct Args {
    #[arg(value_enum, help = "Target shell (bash, zsh, or fish)")]
    shell: Shell,

    #[arg(long, help = "Include short aliases (gwco, etc.)")]
    aliases: bool,
}

pub fn run() -> Result<()> {
    // Skip the first two args ("daft" and "shell-init") to let clap parse from "shell-init"
    let args: Vec<String> = std::env::args().skip(1).collect();
    let args = Args::parse_from(args);

    let shell_name = match args.shell {
        Shell::Bash => "bash",
        Shell::Zsh => "zsh",
        Shell::Fish => "fish",
    };

    let mut output = match args.shell {
        Shell::Bash | Shell::Zsh => generate_bash_zsh(args.aliases),
        Shell::Fish => generate_fish(args.aliases),
    };

    // Append shell completions so users get tab completion out of the box
    output.push_str("\n# Shell completions\n");
    output.push_str(&super::completions::generate_all_completions(shell_name)?);

    println!("{output}");

    // Silently install Fig/Amazon Q specs if the autocomplete directory exists
    super::completions::maybe_install_fig_specs();

    Ok(())
}

fn generate_bash_zsh(include_aliases: bool) -> String {
    let mut output = String::from(BASH_ZSH_WRAPPER);

    if include_aliases {
        output.push_str(BASH_ZSH_ALIASES);
    }

    output
}

fn generate_fish(include_aliases: bool) -> String {
    let mut output = String::from(FISH_WRAPPER);

    if include_aliases {
        output.push_str(FISH_ALIASES);
    }

    output
}

const BASH_ZSH_WRAPPER: &str = r#"# daft shell wrappers - enables cd into new worktrees
# Generated by: daft shell-init

# Find the daft binary path (resolved eagerly before the daft() function
# shadows the binary; command -v returns the function name once defined)
__daft_bin=$(command -v daft 2>/dev/null)
__daft_find_bin() {
    echo "$__daft_bin"
}

__daft_wrapper() {
    local cmd="$1"; shift
    local exit_code
    local daft_bin=$(__daft_find_bin)
    local cd_file
    cd_file=$(mktemp "${TMPDIR:-/tmp}/daft-cd.XXXXXX")

    if [ -z "$cd_file" ]; then
        # mktemp failed — run without cd support
        if [ -n "$daft_bin" ]; then
            (exec -a "$cmd" "$daft_bin" "$@")
        else
            command "$cmd" "$@"
        fi
        return $?
    fi

    # Stdout flows directly to the terminal — no capture needed.
    if [ -n "$daft_bin" ]; then
        (DAFT_CD_FILE="$cd_file" exec -a "$cmd" "$daft_bin" "$@")
    else
        DAFT_CD_FILE="$cd_file" command "$cmd" "$@"
    fi
    exit_code=$?

    # Always check cd_file regardless of exit code. If the binary wrote a
    # cd target, the user MUST be moved there — their old CWD may have been
    # removed (e.g., worktree-branch-delete may remove the worktree but still
    # exit non-zero due to partial errors like remote branch deletion failure).
    if [ -s "$cd_file" ]; then
        local cd_path
        cd_path=$(cat "$cd_file")
        if [ -n "$cd_path" ] && [ -d "$cd_path" ]; then
            cd "$cd_path" || true
        fi
    fi

    rm -f "$cd_file"
    return $exit_code
}

# Direct command wrappers (for git-worktree-* with hyphens)
git-worktree-clone() { __daft_wrapper git-worktree-clone "$@"; }
git-worktree-init() { __daft_wrapper git-worktree-init "$@"; }
git-worktree-checkout() { __daft_wrapper git-worktree-checkout "$@"; }
git-worktree-carry() { __daft_wrapper git-worktree-carry "$@"; }
git-worktree-prune() { __daft_wrapper git-worktree-prune "$@"; }
git-worktree-branch() { __daft_wrapper git-worktree-branch "$@"; }
git-worktree-branch-delete() { __daft_wrapper git-worktree-branch-delete "$@"; }
git-worktree-flow-adopt() { __daft_wrapper git-worktree-flow-adopt "$@"; }
git-worktree-flow-eject() { __daft_wrapper git-worktree-flow-eject "$@"; }

# Git wrapper to intercept "git worktree-*" subcommands (with spaces)
git() {
    case "$1" in
        worktree-clone)
            shift; __daft_wrapper git-worktree-clone "$@" ;;
        worktree-init)
            shift; __daft_wrapper git-worktree-init "$@" ;;
        worktree-checkout)
            shift; __daft_wrapper git-worktree-checkout "$@" ;;
        worktree-carry)
            shift; __daft_wrapper git-worktree-carry "$@" ;;
        worktree-prune)
            shift; __daft_wrapper git-worktree-prune "$@" ;;
        worktree-branch)
            shift; __daft_wrapper git-worktree-branch "$@" ;;
        worktree-branch-delete)
            shift; __daft_wrapper git-worktree-branch-delete "$@" ;;
        worktree-flow-adopt)
            shift; __daft_wrapper git-worktree-flow-adopt "$@" ;;
        worktree-flow-eject)
            shift; __daft_wrapper git-worktree-flow-eject "$@" ;;
        *)
            command git "$@" ;;
    esac
}

# daft wrapper to intercept "daft worktree-*" and "daft <verb>" subcommands
daft() {
    case "$1" in
        worktree-clone|clone)
            shift; __daft_wrapper git-worktree-clone "$@" ;;
        worktree-init|init)
            shift; __daft_wrapper git-worktree-init "$@" ;;
        worktree-checkout|go)
            shift; __daft_wrapper git-worktree-checkout "$@" ;;
        start)
            shift; __daft_wrapper git-worktree-checkout -b "$@" ;;
        worktree-carry|carry)
            shift; __daft_wrapper git-worktree-carry "$@" ;;
        worktree-prune|prune)
            shift; __daft_wrapper git-worktree-prune "$@" ;;
        worktree-branch)
            shift; __daft_wrapper git-worktree-branch "$@" ;;
        remove)
            shift; __daft_wrapper daft-remove "$@" ;;
        worktree-branch-delete)
            shift; __daft_wrapper git-worktree-branch-delete "$@" ;;
        rename)
            shift; __daft_wrapper daft-rename "$@" ;;
        worktree-fetch|update)
            shift; __daft_wrapper git-worktree-fetch "$@" ;;
        worktree-flow-adopt|adopt)
            shift; __daft_wrapper git-worktree-flow-adopt "$@" ;;
        worktree-flow-eject|eject)
            shift; __daft_wrapper git-worktree-flow-eject "$@" ;;
        *)
            command daft "$@" ;;
    esac
}

# Shortcut wrappers - these override symlinks to enable cd behavior
# Git-style shortcuts
gwtclone() { __daft_wrapper git-worktree-clone "$@"; }
gwtinit() { __daft_wrapper git-worktree-init "$@"; }
gwtco() { __daft_wrapper git-worktree-checkout "$@"; }
gwtcb() { __daft_wrapper git-worktree-checkout -b "$@"; }
gwtprune() { __daft_wrapper git-worktree-prune "$@"; }
gwtbd() { __daft_wrapper daft-remove "$@"; }
gwtcarry() { __daft_wrapper git-worktree-carry "$@"; }
gwtfetch() { __daft_wrapper git-worktree-fetch "$@"; }
gwtrn() { __daft_wrapper daft-rename "$@"; }

# Shell-style shortcuts
gwco() { __daft_wrapper git-worktree-checkout "$@"; }
gwcob() { __daft_wrapper git-worktree-checkout -b "$@"; }

# Legacy-style shortcuts
gclone() { __daft_wrapper git-worktree-clone "$@"; }
gcw() { __daft_wrapper git-worktree-checkout "$@"; }
gcbw() { __daft_wrapper git-worktree-checkout -b "$@"; }
gprune() { __daft_wrapper git-worktree-prune "$@"; }

# Default branch helper (shared by default-branch shortcuts)
__daft_default_branch() {
  local remote
  remote=$(git config daft.remote 2>/dev/null || echo origin)
  git symbolic-ref "refs/remotes/$remote/HEAD" 2>/dev/null | sed "s|^refs/remotes/$remote/||"
}

# Default-branch shortcuts (shell-init only - resolve default branch dynamically)
gwtcm() {
  local branch
  branch=$(__daft_default_branch)
  if [ -z "$branch" ]; then
    echo "error: could not determine default branch" >&2; return 1
  fi
  __daft_wrapper git-worktree-checkout "$branch" "$@"
}

gwtcbm() {
  local branch
  branch=$(__daft_default_branch)
  if [ -z "$branch" ]; then
    echo "error: could not determine default branch" >&2; return 1
  fi
  __daft_wrapper git-worktree-checkout -b "$@" "$branch"
}

gwcobd() {
  local branch
  branch=$(__daft_default_branch)
  if [ -z "$branch" ]; then
    echo "error: could not determine default branch" >&2; return 1
  fi
  __daft_wrapper git-worktree-checkout -b "$@" "$branch"
}

gcbdw() {
  local branch
  branch=$(__daft_default_branch)
  if [ -z "$branch" ]; then
    echo "error: could not determine default branch" >&2; return 1
  fi
  __daft_wrapper git-worktree-checkout -b "$@" "$branch"
}
"#;

const BASH_ZSH_ALIASES: &str = r#"
# Short aliases for convenience
alias gwclone='git-worktree-clone'
alias gwinit='git-worktree-init'
alias gwco='git-worktree-checkout'
alias gwcarry='git-worktree-carry'
alias gwprune='git-worktree-prune'
"#;

const FISH_WRAPPER: &str = r#"# daft shell wrappers - enables cd into new worktrees
# Generated by: daft shell-init

# Find the daft binary path
function __daft_find_bin
    set -l daft_bin (command -v daft 2>/dev/null)
    echo $daft_bin
end

function __daft_wrapper
    set -l cmd $argv[1]
    set -l args $argv[2..-1]
    set -l daft_bin (__daft_find_bin)
    set -l cd_file (mktemp (set -q TMPDIR; and echo $TMPDIR; or echo /tmp)"/daft-cd.XXXXXX")

    if test -z "$cd_file"
        if test -n "$daft_bin"
            command $daft_bin $args
        else
            command $cmd $args
        end
        return $status
    end

    # Stdout flows directly to the terminal — no capture needed.
    if test -n "$daft_bin"
        env DAFT_CD_FILE="$cd_file" bash -c 'exec -a "$0" "$1" "${@:2}"' "$cmd" "$daft_bin" $args
    else
        env DAFT_CD_FILE="$cd_file" command $cmd $args
    end
    set -l exit_code $status

    # Always check cd_file regardless of exit code — see bash wrapper comment.
    if test -s "$cd_file"
        set -l cd_path (cat "$cd_file")
        if test -n "$cd_path"; and test -d "$cd_path"
            cd $cd_path
        end
    end

    rm -f "$cd_file"
    return $exit_code
end

# Direct command wrappers (for git-worktree-* with hyphens)
function git-worktree-clone
    __daft_wrapper git-worktree-clone $argv
end

function git-worktree-init
    __daft_wrapper git-worktree-init $argv
end

function git-worktree-checkout
    __daft_wrapper git-worktree-checkout $argv
end

function git-worktree-carry
    __daft_wrapper git-worktree-carry $argv
end

function git-worktree-prune
    __daft_wrapper git-worktree-prune $argv
end

function git-worktree-branch
    __daft_wrapper git-worktree-branch $argv
end

function git-worktree-branch-delete
    __daft_wrapper git-worktree-branch-delete $argv
end

function git-worktree-flow-adopt
    __daft_wrapper git-worktree-flow-adopt $argv
end

function git-worktree-flow-eject
    __daft_wrapper git-worktree-flow-eject $argv
end

# Git wrapper to intercept "git worktree-*" subcommands (with spaces)
function git --wraps git
    switch $argv[1]
        case worktree-clone
            __daft_wrapper git-worktree-clone $argv[2..-1]
        case worktree-init
            __daft_wrapper git-worktree-init $argv[2..-1]
        case worktree-checkout
            __daft_wrapper git-worktree-checkout $argv[2..-1]
        case worktree-carry
            __daft_wrapper git-worktree-carry $argv[2..-1]
        case worktree-prune
            __daft_wrapper git-worktree-prune $argv[2..-1]
        case worktree-branch
            __daft_wrapper git-worktree-branch $argv[2..-1]
        case worktree-branch-delete
            __daft_wrapper git-worktree-branch-delete $argv[2..-1]
        case worktree-flow-adopt
            __daft_wrapper git-worktree-flow-adopt $argv[2..-1]
        case worktree-flow-eject
            __daft_wrapper git-worktree-flow-eject $argv[2..-1]
        case '*'
            command git $argv
    end
end

# daft wrapper to intercept "daft worktree-*" and "daft <verb>" subcommands
function daft --wraps daft
    switch $argv[1]
        case worktree-clone clone
            __daft_wrapper git-worktree-clone $argv[2..-1]
        case worktree-init init
            __daft_wrapper git-worktree-init $argv[2..-1]
        case worktree-checkout go
            __daft_wrapper git-worktree-checkout $argv[2..-1]
        case start
            __daft_wrapper git-worktree-checkout -b $argv[2..-1]
        case worktree-carry carry
            __daft_wrapper git-worktree-carry $argv[2..-1]
        case worktree-prune prune
            __daft_wrapper git-worktree-prune $argv[2..-1]
        case worktree-branch
            __daft_wrapper git-worktree-branch $argv[2..-1]
        case remove
            __daft_wrapper daft-remove $argv[2..-1]
        case worktree-branch-delete
            __daft_wrapper git-worktree-branch-delete $argv[2..-1]
        case rename
            __daft_wrapper daft-rename $argv[2..-1]
        case worktree-fetch update
            __daft_wrapper git-worktree-fetch $argv[2..-1]
        case worktree-flow-adopt adopt
            __daft_wrapper git-worktree-flow-adopt $argv[2..-1]
        case worktree-flow-eject eject
            __daft_wrapper git-worktree-flow-eject $argv[2..-1]
        case '*'
            command daft $argv
    end
end

# Shortcut wrappers - these override symlinks to enable cd behavior
# Git-style shortcuts
function gwtclone
    __daft_wrapper git-worktree-clone $argv
end

function gwtinit
    __daft_wrapper git-worktree-init $argv
end

function gwtco
    __daft_wrapper git-worktree-checkout $argv
end

function gwtcb
    __daft_wrapper git-worktree-checkout -b $argv
end

function gwtprune
    __daft_wrapper git-worktree-prune $argv
end

function gwtbd
    __daft_wrapper daft-remove $argv
end

function gwtcarry
    __daft_wrapper git-worktree-carry $argv
end

function gwtfetch
    __daft_wrapper git-worktree-fetch $argv
end

function gwtrn
    __daft_wrapper daft-rename $argv
end

# Shell-style shortcuts
function gwco
    __daft_wrapper git-worktree-checkout $argv
end

function gwcob
    __daft_wrapper git-worktree-checkout -b $argv
end

# Legacy-style shortcuts
function gclone
    __daft_wrapper git-worktree-clone $argv
end

function gcw
    __daft_wrapper git-worktree-checkout $argv
end

function gcbw
    __daft_wrapper git-worktree-checkout -b $argv
end

function gprune
    __daft_wrapper git-worktree-prune $argv
end

# Default branch helper (shared by default-branch shortcuts)
function __daft_default_branch
    set -l remote (git config daft.remote 2>/dev/null; or echo origin)
    git symbolic-ref "refs/remotes/$remote/HEAD" 2>/dev/null | string replace "refs/remotes/$remote/" ""
end

# Default-branch shortcuts (shell-init only - resolve default branch dynamically)
function gwtcm
    set -l branch (__daft_default_branch)
    if test -z "$branch"
        echo "error: could not determine default branch" >&2; return 1
    end
    __daft_wrapper git-worktree-checkout "$branch" $argv
end

function gwtcbm
    set -l branch (__daft_default_branch)
    if test -z "$branch"
        echo "error: could not determine default branch" >&2; return 1
    end
    __daft_wrapper git-worktree-checkout -b $argv "$branch"
end

function gwcobd
    set -l branch (__daft_default_branch)
    if test -z "$branch"
        echo "error: could not determine default branch" >&2; return 1
    end
    __daft_wrapper git-worktree-checkout -b $argv "$branch"
end

function gcbdw
    set -l branch (__daft_default_branch)
    if test -z "$branch"
        echo "error: could not determine default branch" >&2; return 1
    end
    __daft_wrapper git-worktree-checkout -b $argv "$branch"
end
"#;

const FISH_ALIASES: &str = r#"
# Short aliases for convenience
alias gwclone='git-worktree-clone'
alias gwinit='git-worktree-init'
alias gwco='git-worktree-checkout'
alias gwcarry='git-worktree-carry'
alias gwprune='git-worktree-prune'
"#;
