use anyhow::Result;
use clap::{Parser, ValueEnum};

#[derive(Debug, Clone, ValueEnum)]
pub enum Shell {
    Bash,
    Zsh,
    Fish,
}

#[derive(Parser)]
#[command(name = "shell-init")]
#[command(about = "Generate shell wrapper functions for daft commands")]
#[command(long_about = r#"
Generate shell wrapper functions that enable automatic cd into new worktrees.

By default, when daft commands create or switch to a worktree, the process changes
directory but the parent shell remains in the original directory. These wrappers
solve this by parsing the command output and using the shell's builtin cd.

Add to your shell config:
  Bash (~/.bashrc):  eval "$(daft shell-init bash)"
  Zsh  (~/.zshrc):   eval "$(daft shell-init zsh)"
  Fish (~/.config/fish/config.fish): daft shell-init fish | source

With short aliases (gwco, gwcob, etc.):
  eval "$(daft shell-init bash --aliases)"
"#)]
pub struct Args {
    #[arg(value_enum, help = "Target shell (bash, zsh, or fish)")]
    shell: Shell,

    #[arg(long, help = "Include short aliases (gwco, gwcob, etc.)")]
    aliases: bool,
}

pub fn run() -> Result<()> {
    // Skip the first two args ("daft" and "shell-init") to let clap parse from "shell-init"
    let args: Vec<String> = std::env::args().skip(1).collect();
    let args = Args::parse_from(args);

    let shell_name = match args.shell {
        Shell::Bash => "bash",
        Shell::Zsh => "zsh",
        Shell::Fish => "fish",
    };

    let mut output = match args.shell {
        Shell::Bash | Shell::Zsh => generate_bash_zsh(args.aliases),
        Shell::Fish => generate_fish(args.aliases),
    };

    // Append shell completions so users get tab completion out of the box
    output.push_str("\n# Shell completions\n");
    output.push_str(&super::completions::generate_all_completions(shell_name)?);

    println!("{output}");

    // Silently install Fig/Amazon Q specs if the autocomplete directory exists
    super::completions::maybe_install_fig_specs();

    Ok(())
}

fn generate_bash_zsh(include_aliases: bool) -> String {
    let mut output = String::from(BASH_ZSH_WRAPPER);

    if include_aliases {
        output.push_str(BASH_ZSH_ALIASES);
    }

    output
}

fn generate_fish(include_aliases: bool) -> String {
    let mut output = String::from(FISH_WRAPPER);

    if include_aliases {
        output.push_str(FISH_ALIASES);
    }

    output
}

const BASH_ZSH_WRAPPER: &str = r#"# daft shell wrappers - enables cd into new worktrees
# Generated by: daft shell-init

# Find the daft binary path (cached for performance)
__daft_bin=""
__daft_find_bin() {
    if [ -z "$__daft_bin" ]; then
        __daft_bin=$(command -v daft 2>/dev/null)
    fi
    echo "$__daft_bin"
}

__daft_wrapper() {
    local cmd="$1"; shift
    local output exit_code
    local daft_bin=$(__daft_find_bin)

    # Use exec -a to invoke daft with the command name as argv[0]
    # This works even when symlinks aren't installed (e.g., Homebrew)
    if [ -n "$daft_bin" ]; then
        output=$(DAFT_SHELL_WRAPPER=1 exec -a "$cmd" "$daft_bin" "$@" 2>&1)
    else
        # Fallback: try direct command (for systems with symlinks)
        output=$(DAFT_SHELL_WRAPPER=1 command "$cmd" "$@" 2>&1)
    fi
    exit_code=$?
    echo "$output" | grep -v '^__DAFT_CD__:'
    if [ $exit_code -eq 0 ]; then
        local cd_path
        cd_path=$(echo "$output" | grep '^__DAFT_CD__:' | cut -d: -f2-)
        if [ -n "$cd_path" ] && [ -d "$cd_path" ]; then
            cd "$cd_path" || return $exit_code
        fi
    fi
    return $exit_code
}

# Direct command wrappers (for git-worktree-* with hyphens)
git-worktree-clone() { __daft_wrapper git-worktree-clone "$@"; }
git-worktree-init() { __daft_wrapper git-worktree-init "$@"; }
git-worktree-checkout() { __daft_wrapper git-worktree-checkout "$@"; }
git-worktree-checkout-branch() { __daft_wrapper git-worktree-checkout-branch "$@"; }
git-worktree-checkout-branch-from-default() { __daft_wrapper git-worktree-checkout-branch-from-default "$@"; }
git-worktree-carry() { __daft_wrapper git-worktree-carry "$@"; }
git-worktree-prune() { __daft_wrapper git-worktree-prune "$@"; }
git-worktree-flow-adopt() { __daft_wrapper git-worktree-flow-adopt "$@"; }
git-worktree-flow-eject() { __daft_wrapper git-worktree-flow-eject "$@"; }

# Git wrapper to intercept "git worktree-*" subcommands (with spaces)
git() {
    case "$1" in
        worktree-clone)
            shift; __daft_wrapper git-worktree-clone "$@" ;;
        worktree-init)
            shift; __daft_wrapper git-worktree-init "$@" ;;
        worktree-checkout)
            shift; __daft_wrapper git-worktree-checkout "$@" ;;
        worktree-checkout-branch)
            shift; __daft_wrapper git-worktree-checkout-branch "$@" ;;
        worktree-checkout-branch-from-default)
            shift; __daft_wrapper git-worktree-checkout-branch-from-default "$@" ;;
        worktree-carry)
            shift; __daft_wrapper git-worktree-carry "$@" ;;
        worktree-prune)
            shift; __daft_wrapper git-worktree-prune "$@" ;;
        worktree-flow-adopt)
            shift; __daft_wrapper git-worktree-flow-adopt "$@" ;;
        worktree-flow-eject)
            shift; __daft_wrapper git-worktree-flow-eject "$@" ;;
        *)
            command git "$@" ;;
    esac
}

# daft wrapper to intercept "daft worktree-*" subcommands
daft() {
    case "$1" in
        worktree-clone)
            shift; __daft_wrapper git-worktree-clone "$@" ;;
        worktree-init)
            shift; __daft_wrapper git-worktree-init "$@" ;;
        worktree-checkout)
            shift; __daft_wrapper git-worktree-checkout "$@" ;;
        worktree-checkout-branch)
            shift; __daft_wrapper git-worktree-checkout-branch "$@" ;;
        worktree-checkout-branch-from-default)
            shift; __daft_wrapper git-worktree-checkout-branch-from-default "$@" ;;
        worktree-carry)
            shift; __daft_wrapper git-worktree-carry "$@" ;;
        worktree-prune)
            shift; __daft_wrapper git-worktree-prune "$@" ;;
        worktree-fetch)
            shift; __daft_wrapper git-worktree-fetch "$@" ;;
        worktree-flow-adopt)
            shift; __daft_wrapper git-worktree-flow-adopt "$@" ;;
        worktree-flow-eject)
            shift; __daft_wrapper git-worktree-flow-eject "$@" ;;
        *)
            command daft "$@" ;;
    esac
}

# Shortcut wrappers - these override symlinks to enable cd behavior
# Git-style shortcuts
gwtclone() { __daft_wrapper git-worktree-clone "$@"; }
gwtinit() { __daft_wrapper git-worktree-init "$@"; }
gwtco() { __daft_wrapper git-worktree-checkout "$@"; }
gwtcb() { __daft_wrapper git-worktree-checkout-branch "$@"; }
gwtcbm() { __daft_wrapper git-worktree-checkout-branch-from-default "$@"; }
gwtprune() { __daft_wrapper git-worktree-prune "$@"; }
gwtcarry() { __daft_wrapper git-worktree-carry "$@"; }
gwtfetch() { __daft_wrapper git-worktree-fetch "$@"; }

# Shell-style shortcuts
gwco() { __daft_wrapper git-worktree-checkout "$@"; }
gwcob() { __daft_wrapper git-worktree-checkout-branch "$@"; }
gwcobd() { __daft_wrapper git-worktree-checkout-branch-from-default "$@"; }

# Legacy-style shortcuts
gclone() { __daft_wrapper git-worktree-clone "$@"; }
gcw() { __daft_wrapper git-worktree-checkout "$@"; }
gcbw() { __daft_wrapper git-worktree-checkout-branch "$@"; }
gcbdw() { __daft_wrapper git-worktree-checkout-branch-from-default "$@"; }
gprune() { __daft_wrapper git-worktree-prune "$@"; }
"#;

const BASH_ZSH_ALIASES: &str = r#"
# Short aliases for convenience
alias gwclone='git-worktree-clone'
alias gwinit='git-worktree-init'
alias gwco='git-worktree-checkout'
alias gwcob='git-worktree-checkout-branch'
alias gwcobd='git-worktree-checkout-branch-from-default'
alias gwcarry='git-worktree-carry'
alias gwprune='git-worktree-prune'
"#;

const FISH_WRAPPER: &str = r#"# daft shell wrappers - enables cd into new worktrees
# Generated by: daft shell-init

# Find the daft binary path
function __daft_find_bin
    set -l daft_bin (command -v daft 2>/dev/null)
    echo $daft_bin
end

function __daft_wrapper
    set -l cmd $argv[1]
    set -l args $argv[2..-1]
    set -l daft_bin (__daft_find_bin)
    set -l output
    set -l exit_code

    # Use exec to invoke daft with the command name as argv[0]
    # Fish doesn't have exec -a, so we use a bash subshell for this
    if test -n "$daft_bin"
        set output (env DAFT_SHELL_WRAPPER=1 bash -c 'exec -a "$0" "$1" "${@:2}"' "$cmd" "$daft_bin" $args 2>&1)
    else
        # Fallback: try direct command (for systems with symlinks)
        set output (env DAFT_SHELL_WRAPPER=1 command $cmd $args 2>&1)
    end
    set exit_code $status

    # Print output, filtering out the cd path marker
    for line in $output
        if not string match -q '__DAFT_CD__:*' $line
            echo $line
        end
    end

    # If successful, cd to the target directory
    if test $exit_code -eq 0
        for line in $output
            if string match -q '__DAFT_CD__:*' $line
                set -l cd_path (string replace '__DAFT_CD__:' '' $line)
                if test -n "$cd_path"; and test -d "$cd_path"
                    cd $cd_path
                end
                break
            end
        end
    end

    return $exit_code
end

# Direct command wrappers (for git-worktree-* with hyphens)
function git-worktree-clone
    __daft_wrapper git-worktree-clone $argv
end

function git-worktree-init
    __daft_wrapper git-worktree-init $argv
end

function git-worktree-checkout
    __daft_wrapper git-worktree-checkout $argv
end

function git-worktree-checkout-branch
    __daft_wrapper git-worktree-checkout-branch $argv
end

function git-worktree-checkout-branch-from-default
    __daft_wrapper git-worktree-checkout-branch-from-default $argv
end

function git-worktree-carry
    __daft_wrapper git-worktree-carry $argv
end

function git-worktree-prune
    __daft_wrapper git-worktree-prune $argv
end

function git-worktree-flow-adopt
    __daft_wrapper git-worktree-flow-adopt $argv
end

function git-worktree-flow-eject
    __daft_wrapper git-worktree-flow-eject $argv
end

# Git wrapper to intercept "git worktree-*" subcommands (with spaces)
function git --wraps git
    switch $argv[1]
        case worktree-clone
            __daft_wrapper git-worktree-clone $argv[2..-1]
        case worktree-init
            __daft_wrapper git-worktree-init $argv[2..-1]
        case worktree-checkout
            __daft_wrapper git-worktree-checkout $argv[2..-1]
        case worktree-checkout-branch
            __daft_wrapper git-worktree-checkout-branch $argv[2..-1]
        case worktree-checkout-branch-from-default
            __daft_wrapper git-worktree-checkout-branch-from-default $argv[2..-1]
        case worktree-carry
            __daft_wrapper git-worktree-carry $argv[2..-1]
        case worktree-prune
            __daft_wrapper git-worktree-prune $argv[2..-1]
        case worktree-flow-adopt
            __daft_wrapper git-worktree-flow-adopt $argv[2..-1]
        case worktree-flow-eject
            __daft_wrapper git-worktree-flow-eject $argv[2..-1]
        case '*'
            command git $argv
    end
end

# daft wrapper to intercept "daft worktree-*" subcommands
function daft --wraps daft
    switch $argv[1]
        case worktree-clone
            __daft_wrapper git-worktree-clone $argv[2..-1]
        case worktree-init
            __daft_wrapper git-worktree-init $argv[2..-1]
        case worktree-checkout
            __daft_wrapper git-worktree-checkout $argv[2..-1]
        case worktree-checkout-branch
            __daft_wrapper git-worktree-checkout-branch $argv[2..-1]
        case worktree-checkout-branch-from-default
            __daft_wrapper git-worktree-checkout-branch-from-default $argv[2..-1]
        case worktree-carry
            __daft_wrapper git-worktree-carry $argv[2..-1]
        case worktree-prune
            __daft_wrapper git-worktree-prune $argv[2..-1]
        case worktree-fetch
            __daft_wrapper git-worktree-fetch $argv[2..-1]
        case worktree-flow-adopt
            __daft_wrapper git-worktree-flow-adopt $argv[2..-1]
        case worktree-flow-eject
            __daft_wrapper git-worktree-flow-eject $argv[2..-1]
        case '*'
            command daft $argv
    end
end

# Shortcut wrappers - these override symlinks to enable cd behavior
# Git-style shortcuts
function gwtclone
    __daft_wrapper git-worktree-clone $argv
end

function gwtinit
    __daft_wrapper git-worktree-init $argv
end

function gwtco
    __daft_wrapper git-worktree-checkout $argv
end

function gwtcb
    __daft_wrapper git-worktree-checkout-branch $argv
end

function gwtcbm
    __daft_wrapper git-worktree-checkout-branch-from-default $argv
end

function gwtprune
    __daft_wrapper git-worktree-prune $argv
end

function gwtcarry
    __daft_wrapper git-worktree-carry $argv
end

function gwtfetch
    __daft_wrapper git-worktree-fetch $argv
end

# Shell-style shortcuts
function gwco
    __daft_wrapper git-worktree-checkout $argv
end

function gwcob
    __daft_wrapper git-worktree-checkout-branch $argv
end

function gwcobd
    __daft_wrapper git-worktree-checkout-branch-from-default $argv
end

# Legacy-style shortcuts
function gclone
    __daft_wrapper git-worktree-clone $argv
end

function gcw
    __daft_wrapper git-worktree-checkout $argv
end

function gcbw
    __daft_wrapper git-worktree-checkout-branch $argv
end

function gcbdw
    __daft_wrapper git-worktree-checkout-branch-from-default $argv
end

function gprune
    __daft_wrapper git-worktree-prune $argv
end
"#;

const FISH_ALIASES: &str = r#"
# Short aliases for convenience
alias gwclone='git-worktree-clone'
alias gwinit='git-worktree-init'
alias gwco='git-worktree-checkout'
alias gwcob='git-worktree-checkout-branch'
alias gwcobd='git-worktree-checkout-branch-from-default'
alias gwcarry='git-worktree-carry'
alias gwprune='git-worktree-prune'
"#;
